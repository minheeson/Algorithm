## 06-3 BOGGLE

### 예제 : 보글 게임 (문제 ID : BOGGLE)

> 보글(Boggle) 게임은 5x5 크기의 알파벳 격자인 게임판의 한 글자에서 시작해서 펜을 움직이면서 만나는 글자를 그 순서대로 나열하여 만들어지는 영어 단어를 찾아내는 게임입니다. 펜은 상하좌우, 혹은 대각선으로 인접한 칸으로 이동할 수 있으며 글자를 건너뛸 수는 없습니다. 지나간 글자를 다시 지나가는 것은 가능하지만, 펜을 이동하지않고 같은 글자를 여러번 쓸 수는 없습니다.
>
> 보글 게임판과 알고 있는 단어들의 목록이 주어질 때, 보글 게임판에서 각 단어를 찾을 수 있는지 여부를 출력하는 프로그램을 작성하세요.
>
> hasWord(y, x, word) = 보글 게임판의 (y, x) 에서 시작하는 단어 word의 존재 여부를 반환한다.

- **문제의 분할** 

  - hasWord()가 하는 일을 조각내는 방법은 각 글자를 하나의 조각으로 만드는 것 

- **기저 사례의 선택** 

  - 위치 (y, x)에 있는 글자가 원하는 단어의 첫 글자가 아닌 경우 항상 실패
  - (위의 경우에 해당하지 않을 경우) 원하는 단어가 한 글자인 경우 항상 성공 

- **구현** 

  ```java
  static boolean hasWord(int y, int x, String word) {
  	// 기저 사례 1 : 시작 위치가 범위 밖이면 실패
  	if (!inRange(y, x))
  		return false;
  	// 기저 사례 2 : 첫 글자가 일치하지 않으면 실패
  	if (board[y][x] != word.charAt(0))
  		return false;
  	// 기저 사례 3 : 단어 길이가 1이면 성공
  	if (word.length() == 1)
  		return true;

  	for (int direction = 0; direction < 8; direction++) {
  		int nextY = y + dy[direction];
  		int nextX = x + dx[direction];
  		if (hasWord(nextY, nextX, word.substring(1))) {
  			return true;
  		}
  	}
    
  	return false;
  }
  ```

- **시간 복잡도 분석**

  - 완전 탐색은 가능한 답 후보들을 모두 만들어 보기 때문에, 시간 복잡도를 계산하기 위해서는 가능한 후보의 수를 전부 세어 보기만 하면 됨 
  - 마지막 글자에 도달하기 전에는 주변의 모든 칸에 대해 재귀 호출을 하게 됨 
  - 각 칸에는 최대 8개의 이웃이 있고, 탐색은 단어의 길이 *N*에 대해 *N-1*단계 진행됨
  - 따라서, 검사하는 후보의 수는 최대 **8^*N-1* = O(8^*N*)**